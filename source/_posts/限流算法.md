---
title:  几种限流算法 
date:  2020-12-02 15:30:16 
tags: [算法,限流] 
categories: "微服务"
---

#### 1、计数器/时间窗口法

这种限流算法最简单，也是最容易实现的，通过在单位时间内设置最大访问数就可达到限流的目的。例如：某系统能够承受的QPS为60，在单位时间一秒内限制接口只能被访问60次即可；

- 缺陷：假如在时间窗的钱1%的时间内流量就达到顶峰，那么在剩余99%的时间系统即便能够继续提供服务，还是会被限流算法阻断，这种缺陷也被称为“突刺效应”。限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。

示例如下：

```java
public class CounterTest {
    public long timeStamp = getNowTime();
    public int reqCount = 0;
    public final int limit = 100; // 时间窗口内最大请求数
    public final long interval = 1000; // 时间窗口ms

    public boolean grant() {
        long now = getNowTime();
        if (now < timeStamp + interval) {
            // 在时间窗口内
            reqCount++;
            // 判断当前时间窗口内是否超过最大请求控制数
            return reqCount <= limit;
        } else {
            timeStamp = now;
            // 超时后重置
            reqCount = 1;
            return true;
        }
    }
    public long getNowTime() {
        return System.currentTimeMillis();
    }
}
```

丢弃的请求都是在单位时间内时间比较靠后的请求；

#### 2、滑动时间窗口限流算法

在任意1秒的时间窗内，接口的请求次数都不能大于K次。

维护一个K+1的循环队列，用来记录1秒内的请求（当队列满时，tail指向的位置实际上是没有存储数据的，所以循环队列会浪费一个数组的存储空间），当有新的请求到来时，将于这个请求的时间超过1秒的请求，从队列中删除，同时，检查循环队列中是否存在空闲位置，如果存在，则把新的请求存储在队列的尾部，如果没有，则说明1秒内请求次数已经超过限流值K，所以这个请求被拒绝请求服务；

- 缺点：只能在选定时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。

  相对第一种丢弃的请求比较随机，但不是权重平等的丢弃请求。

#### 3、漏桶算法

漏铜算法可以 解决“突刺效应”，当请求进来时，详单与水倒入漏斗，然后下端小口慢慢均匀的流出，不管上面流量多大，下面流出的速度始终保持不变，如果桶满了，那么进来的请求就丢弃。**实现**可以用队列保存请求，另外通过线程池来顶起从队列中获取请求并执行，可以一次性获取多个并发执行；

- 无法应对短时间内的突发流量。

#### 4、令牌桶算法

从某种意义上讲，令牌桶算法算是漏铜算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。



在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定速率向桶中方令牌。每次请求需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择等待可用的令牌，获取直接拒绝。



放令牌的动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以存在这种情况，桶中一直有大量的可用令牌，这是进来的请求就可以直接拿到令牌执行。例如：设置QPS为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这是服务还没完全启动，等启动完成对外提供服务时，该限流器就可以抵挡瞬时的100个请求。所以只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。

![2020010701](/blog/images/2020010701.png)

相对另外三种限流算法，令牌桶算法在流量到达上限时不是直接丢弃请求，而是通过令牌生成的速率实现限流的。